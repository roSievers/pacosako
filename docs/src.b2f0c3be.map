{"version":3,"sources":["basicTypes.ts","paco.ts","index.ts"],"names":[],"mappings":"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","file":"src.b2f0c3be.map","sourceRoot":"../src","sourcesContent":["// basicTypes.ts\n\n/**\n * The PieceType enum lists all possible kinds of chess pieces.\n * Pawn, Rock, Knight, Bishop, Queen, King\n */\nexport enum PieceType {\n  pawn,\n  rock,\n  knight,\n  bishop,\n  queen,\n  king\n}\n\n/**\n * Current state of the Piece. This describes the situation in which the piece\n * is on its tile.\n */\nexport enum PieceState {\n  alone,\n  dancing,\n  takingOver,\n  leavingUnion\n}\n\n/**\n * The PlayerColor is either white or black.\n */\nexport enum PlayerColor {\n  white,\n  black\n}\n\n/**\n * The TileColor is either white or black. This is separate from the PlayerColor\n * as they are not related.\n */\nexport enum TileColor {\n  white,\n  black\n}\n\n/**\n * The Position class expresses a position on the board. Both x and y\n * must be in the set {0, 1, .., 7}. A Position is immutable.\n */\nexport class Position {\n  constructor(public readonly x: number, public readonly y: number) {\n    if (x < 0 || 7 < x || y < 0 || 7 < y) {\n      throw new Error(\"Can't initialize Position with x=${x}, y=${y}.\");\n    }\n  }\n  equals(other: Position): boolean {\n    return this.x == other.x && this.y == other.y;\n  }\n  /**\n   * Helper function for coloring the tiles.\n   * @param p\n   */\n  get isEven(): boolean {\n    return (this.x + this.y) % 2 == 0;\n  }\n}\n\n/**\n * The Vector class expresses an immutable pair of numbers x, y.\n */\nexport class Vector {\n  constructor(public readonly x: number, public readonly y: number) {}\n  /** Returns a new zero vector. */\n  static get zero(): Vector {\n    return new Vector(0, 0);\n  }\n  /** Returns a new vector with the given x and y = 0. */\n  static x(_x: number): Vector {\n    return new Vector(_x, 0);\n  }\n  /** Returns a new vector with x = 0 and the given y. */\n  static y(_y: number): Vector {\n    return new Vector(0, _y);\n  }\n  /** Takes another Vector and returns the sum as a new Vector. */\n  add(other: Vector): Vector {\n    return new Vector(this.x + other.x, this.y + other.y);\n  }\n}\n\n/**\n * Helper function to turn an internal position {x:5, y:2} into a human readable\n * position \"f3\".\n * @param p\n */\nexport function chessPosition(p: Position): string {\n  return \"abcdefgh\"[p.x] + p.y;\n}\n\n/**\n * The BoardMap class implements a Map object which takes Position as the index\n * and stores a value of type T.\n */\nexport class BoardMap<T> {\n  private values: Array<Array<T>> = new Array(8);\n  constructor(init: (p: Position) => T) {\n    for (let x = 0; x < 8; x++) {\n      this.values[x] = new Array(8);\n      for (let y = 0; y < 8; y++) {\n        this.values[x][y] = init(new Position(x, y));\n      }\n    }\n  }\n  public get(p: Position): T {\n    return this.values[p.x][p.y];\n  }\n  public set(p: Position, value: T) {\n    this.values[p.x][p.y] = value;\n  }\n  /**\n   * The `forEach()` method executes a provided function once for each position\n   * of the Board. It will execute the leftmost column first from top to bottom\n   * and then continue column by column.\n   * @param f Function to execute for each element.\n   */\n  public forEach(f: (p: Position, v: T, map: BoardMap<T>) => any) {\n    for (let x = 0; x < 8; x++) {\n      for (let y = 0; y < 8; y++) {\n        f(new Position(x, y), this.get(new Position(x, y)), this);\n      }\n    }\n  }\n}\n\n/**\n * A very basic implementation of observables.\n */\nexport class Observable<T> {\n  private subscribers: Array<Observer<T>> = new Array();\n  constructor(private _value: T) {}\n  get value() {\n    return this._value;\n  }\n  set value(newValue: T) {\n    this._value = newValue;\n    this.subscribers.forEach(observer => {\n      observer(newValue);\n    });\n  }\n  subscribe(observer: Observer<T>) {\n    this.subscribers.push(observer);\n  }\n}\n\n/**\n * An Observer<T> is just a function that gets called on change.\n */\nexport type Observer<T> = (newValue: T) => any;\n","// Implements the core game logic of Paco Ŝako.\n// As \"PacoSxako\" does not look nice when spelled with \"iks-sistemo\",\n// this module is called paco.ts instead.\nimport {\n  Position,\n  PlayerColor,\n  PieceType,\n  Observable,\n  PieceState\n} from \"./basicTypes\";\n\n/**\n * A ChessPiece is a data object which tracks its inherent properties\n * and its position.\n */\nexport class ChessPiece {\n  public stateObs: Observable<PieceState> = new Observable(PieceState.alone);\n  private _type: PieceType;\n  public positionObs: Observable<Position>;\n  constructor(\n    type: PieceType,\n    public readonly color: PlayerColor,\n    position: Position\n  ) {\n    this.positionObs = new Observable(position);\n    this._type = type;\n  }\n  /**\n   * Returns the type of a piece. This must be a propperty in order to\n   * implement promotion while keeping this.type readonly.\n   */\n  get type() {\n    return this._type;\n  }\n  get position(): Position {\n    return this.positionObs.value;\n  }\n  set position(newPosition: Position) {\n    this.positionObs.value = newPosition;\n  }\n  get state(): PieceState {\n    return this.stateObs.value;\n  }\n  set state(newState: PieceState) {\n    this.stateObs.value = newState;\n  }\n  /**\n   * This function promotes a pawn to a queen if possible.\n   * @throws If the piece is not a pawn or at the wrong position.\n   */\n  promote() {\n    if (this._type != PieceType.pawn) {\n      throw new Error(\"Only pawns can be promoted.\");\n    } else if (this.color == PlayerColor.black && this.position.y != 0) {\n      throw new Error(\"Black pawns may only be promoted in row 0.\");\n    } else if (this.color == PlayerColor.white && this.position.y != 7) {\n      throw new Error(\"White pawns may only be promoted in row 7\");\n    } else {\n      this._type = PieceType.queen;\n    }\n  }\n}\n\nexport class ChessPair {\n  public readonly white: ChessPiece;\n  public readonly black: ChessPiece;\n  /**\n   * Constructs and validates a ChessPair from a list of ChessPiece objects.\n   * @param pieces An array containing a white and a black chess piece on\n   *               the same position in any order.\n   * @throws If the array does not constitute a valid pair.\n   */\n  constructor(pieces: Array<ChessPiece>) {\n    if (pieces.length != 2) {\n      throw new Error(\n        \"A Pair has exactly two members. Recieved: \" + pieces.length\n      );\n    }\n    let whitePiece = pieces.find(piece => piece.color == PlayerColor.white);\n    let blackPiece = pieces.find(piece => piece.color == PlayerColor.black);\n    if (whitePiece == undefined) {\n      throw new Error(\"You did not supply a white piece to the pair.\");\n    } else if (blackPiece == undefined) {\n      throw new Error(\"You did not supply a black piece to the pair.\");\n    } else {\n      this.white = whitePiece;\n      this.black = blackPiece;\n      this.assertIntegrity();\n    }\n  }\n  assertIntegrity() {\n    if (!this.white.position.equals(this.black.position)) {\n      throw new Error(\"Pieces of a pair must share a Position.\");\n    }\n  }\n  get position(): Position {\n    this.assertIntegrity();\n    return this.white.position;\n  }\n  set position(p: Position) {\n    this.white.position = p;\n    this.black.position = p;\n  }\n  ofColor(c: PlayerColor) {\n    if (c == PlayerColor.white) {\n      return this.white;\n    } else {\n      return this.black;\n    }\n  }\n}\n\nexport class PacoBoard {\n  /**\n   * The current state of all pieces. The objects modelling the pieces\n   * will not change during runtime and can be used as keys in a map.\n   */\n  public readonly pieces: Array<ChessPiece> = initEmptyBoard();\n  /**\n   * The piece currently leaving a union without a defined target.\n   */\n  private chaining: ChessPiece | null = null;\n  /** Constructs a new board in initial position. */\n  constructor() {}\n  /**\n   * Given a selection position p, PacoBoard.select(p) returns a list of all\n   * legal moves or null, if a selection can not be made at the given position.\n   *\n   * Note that a selection may itself be legal, but may not offer any legal\n   * moves. For example, a blocked white pawn may be selected by white but\n   * can not be moved. On the other hand, a single black bishop may not be\n   * selected by white at all. An empty square can't be selected either.\n   *\n   * Selection data is not stored in the PacoBoard itself.\n   *\n   * @param p The position the user wants to select.\n   */\n  select(p: Position): Array<Position> | null {\n    if (this.at(p) == null) {\n      return null;\n    } else {\n      // TODO: This function is lacking a propper implementation.\n      return new Array(p);\n    }\n  }\n  /**\n   * Moves the piece or pieces from the start to the target position.\n   * @param start `this.select(start)` must not be `null`.\n   * @param target must be an entry of `this.select(start)`\n   */\n  move(start: Position, target: Position) {\n    let legalMoves = this.select(start);\n    if (legalMoves == null || legalMoves.every(p => !p.equals(target))) {\n      // throw new Error(\"This move is not allowed.\");\n    }\n    // Analize situation\n    if (this.chaining != null) {\n      // A chain is active, the chaining piece must move.\n      if (this.chaining.position.equals(start)) {\n        this.singleMove(this.chaining, target);\n        this._at(start).forEach(piece => (piece.state = PieceState.dancing));\n      } else {\n        throw new Error(\"A chain is active, move the chaining piece.\");\n      }\n    } else {\n      let movingPieces = this.at(start);\n      if (movingPieces instanceof ChessPiece) {\n        // Moving a single piece works just as moving the chain piece\n        this.singleMove(movingPieces, target);\n      } else if (movingPieces instanceof ChessPair) {\n        this.pairMove(movingPieces, target);\n      } else {\n        throw new Error(\"There is no piece at the start position!\");\n      }\n    }\n  }\n  /**\n   * This internal function moves a pair. This is only possible, when the target\n   * position is empty.\n   * @param movingPair The ChessPair being moved.\n   * @param target The target Position.\n   */\n  private pairMove(movingPair: ChessPair, target: Position) {\n    if (this.at(target) == null) {\n      movingPair.position = target;\n    } else {\n      throw new Error(\"Pairs may only be moved onto empty squares.\");\n    }\n  }\n  /**\n   * This internal function moves a single piece. It does not matter whether\n   * the piece is from a chain or not.\n   * @param movingPiece The ChessPiece being moved.\n   * @param target The target Position.\n   */\n  private singleMove(movingPiece: ChessPiece, target: Position) {\n    let targetPieces = this.at(target);\n    if (targetPieces == null) {\n      // Empty target tile, the chain is over.\n      movingPiece.position = target;\n      movingPiece.state = PieceState.alone;\n      this.chaining = null;\n    } else if (targetPieces instanceof ChessPiece) {\n      // Single Target, verify color and move there. The chain is over.\n      if (movingPiece.color == targetPieces.color) {\n        throw new Error(\"Can't form a union from pieces with the same color.\");\n      }\n      movingPiece.position = target;\n      movingPiece.state = PieceState.dancing;\n      targetPieces.state = PieceState.dancing;\n      this.chaining = null;\n    } else {\n      // Pair target, a chain continues or begins\n      movingPiece.position = target;\n      movingPiece.state = PieceState.takingOver;\n      this.chaining = targetPieces.ofColor(movingPiece.color);\n      this.chaining.state = PieceState.leavingUnion;\n    }\n  }\n  /**\n   * Returns all pieces at the given position in an unstructured list.\n   * Note that the `chaining` piece is excluded as it has a virtual position.\n   */\n  private _at(p: Position): Array<ChessPiece> {\n    return this.pieces.filter(\n      chessPiece => chessPiece.position.equals(p) && chessPiece != this.chaining\n    );\n  }\n  /**\n   * Returns all pieces at the given position in a structured form.\n   * Note that the `chaining` piece is excluded as it has a virtual position.\n   * @throws May throw if the internal Board state is inconsistent.\n   */\n  public at(p: Position): null | ChessPiece | ChessPair {\n    let pieces = this._at(p);\n    switch (pieces.length) {\n      case 0:\n        return null;\n      case 1:\n        return pieces[0];\n      case 2:\n        return new ChessPair(pieces);\n      case 3:\n        throw new Error(\n          \"Selecting a tile with three pieces is not implemented.\"\n        );\n      default:\n        throw new Error(\n          \"There are more than 3 pieces on the same tile. This is forbidden.\"\n        );\n    }\n  }\n  get chainingPiece(): ChessPiece | null {\n    return this.chaining;\n  }\n}\n\nconst basePieceOrder: Array<PieceType> = [\n  PieceType.rock,\n  PieceType.knight,\n  PieceType.bishop,\n  PieceType.queen,\n  PieceType.king,\n  PieceType.bishop,\n  PieceType.knight,\n  PieceType.rock\n];\n\nfunction initEmptyBoard(): ChessPiece[] {\n  let pieces: Array<ChessPiece> = new Array(32);\n  // All pawns\n  for (let x = 0; x < 8; x++) {\n    const pW = new Position(x, 1);\n    const w = new Position(x, 0);\n    const pB = new Position(x, 6);\n    const b = new Position(x, 7);\n    pieces[x] = new ChessPiece(PieceType.pawn, PlayerColor.white, pW);\n    pieces[8 + x] = new ChessPiece(basePieceOrder[x], PlayerColor.white, w);\n    pieces[16 + x] = new ChessPiece(PieceType.pawn, PlayerColor.black, pB);\n    pieces[24 + x] = new ChessPiece(basePieceOrder[x], PlayerColor.black, b);\n  }\n  return pieces;\n}\n","// index.ts\nimport {\n  BoardMap,\n  Position,\n  TileColor,\n  PlayerColor,\n  PieceType,\n  Vector,\n  PieceState\n} from \"./basicTypes\";\nimport { PacoBoard, ChessPiece, ChessPair } from \"./paco\";\n\n// Placeholder Graphics from https://openclipart.org/user-detail/akiross\n// TODO: Use a Tileset\n// TODO: Get graphics which look even better.\nconst whitePawnFile: string = require(\"../assets/pawn-w.png\");\nconst whiteRockFile: string = require(\"../assets/rock-w.png\");\nconst whiteKnightFile: string = require(\"../assets/knight-w.png\");\nconst whiteBishopFile: string = require(\"../assets/bishop-w.png\");\nconst whiteQueenFile: string = require(\"../assets/queen-w.png\");\nconst whiteKingFile: string = require(\"../assets/king-w.png\");\nconst blackPawnFile: string = require(\"../assets/pawn-b.png\");\nconst blackRockFile: string = require(\"../assets/rock-b.png\");\nconst blackKnightFile: string = require(\"../assets/knight-b.png\");\nconst blackBishopFile: string = require(\"../assets/bishop-b.png\");\nconst blackQueenFile: string = require(\"../assets/queen-b.png\");\nconst blackKingFile: string = require(\"../assets/king-b.png\");\n\nconst outputContainer = document.getElementById(\"output\");\nif (outputContainer) {\n  outputContainer.innerHTML = \"\";\n}\n\nfunction simpleLog(text: string) {\n  let p = document.createElement(\"p\");\n  p.innerHTML = text;\n  if (outputContainer) {\n    outputContainer.appendChild(p);\n  }\n}\n\nconst blackTileColor = 0x448844;\nconst whiteTileColor = 0xccffcc;\nconst blackTileHighlightColor = 0xaaaa66;\nconst whiteTileHighlightColor = 0xddddcc;\n\nlet pixiNode = document.getElementById(\"pixi\");\n\nlet app = new PIXI.Application(900, 900, {\n  backgroundColor: whiteTileColor\n});\nif (pixiNode) {\n  pixiNode.innerHTML = \"\";\n  pixiNode.appendChild(app.view);\n}\n\nfunction boardBackground() {\n  var graphics = new PIXI.Graphics();\n  graphics.lineStyle();\n  graphics.beginFill(0x000000);\n  graphics.drawRect(45, 45, 810, 810);\n  return graphics;\n}\n\nclass Tile extends PIXI.Graphics {\n  readonly tileColor: TileColor;\n  private highlight: boolean = false;\n  constructor(readonly tilePosition: Position, private board: Board) {\n    super();\n    if (this.tilePosition.isEven) {\n      this.tileColor = TileColor.black;\n    } else {\n      this.tileColor = TileColor.white;\n    }\n    this.determineTint();\n\n    this.lineStyle();\n    this.beginFill(0xffffff);\n    this.drawRect(0, 0, 100, 100);\n    const pos = pixelPosition(tilePosition);\n    this.x = pos.x;\n    this.y = pos.y;\n\n    this.on(\"click\", () => board.onClick(this.tilePosition));\n    this.interactive = true;\n    this.interactiveChildren = false;\n    this.hitArea = new PIXI.Rectangle(0, 0, 100, 100);\n  }\n  determineTint() {\n    if (!this.highlight) {\n      if (this.tileColor == TileColor.white) {\n        this.tint = whiteTileColor;\n      } else {\n        this.tint = blackTileColor;\n      }\n    } else {\n      if (this.tileColor == TileColor.black) {\n        this.tint = blackTileHighlightColor;\n      } else {\n        this.tint = whiteTileHighlightColor;\n      }\n    }\n  }\n  clearHighlight() {\n    this.highlight = false;\n    this.determineTint();\n  }\n  setHighlight() {\n    this.highlight = true;\n    this.determineTint();\n  }\n}\n\nclass Board extends PIXI.Container {\n  /** Represents the piece that is currently held by the player. */\n  private _selection: Position | null = null;\n  /** The tiles which make up the board. */\n  private readonly tiles: BoardMap<Tile>;\n  /** Internal representation of the Board. */\n  private pacoBoard: PacoBoard = new PacoBoard();\n  /** A flat list of all pieces. They remember their own position. */\n  private readonly pieces: Map<ChessPiece, VisualPiece> = this.createPieces();\n  constructor() {\n    super();\n\n    this.tiles = new BoardMap(p => new Tile(p, this));\n    this.tiles.forEach((_, tile) => this.addChild(tile));\n\n    this.pieces.forEach(piece => this.addChild(piece.sprite));\n\n    this.on(\"mousedown\", () => console.log(\"testing\"));\n  }\n  private createPieces(): Map<ChessPiece, VisualPiece> {\n    // Type hint is due to https://github.com/Microsoft/TypeScript/issues/8936\n    return new Map<ChessPiece, VisualPiece>(\n      this.pacoBoard.pieces.map(\n        chessPiece =>\n          [chessPiece, new VisualPiece(chessPiece)] as [ChessPiece, VisualPiece]\n      )\n    );\n  }\n  public getVisual(abstract: ChessPiece): VisualPiece {\n    let visual = this.pieces.get(abstract);\n    if (visual != undefined) {\n      return visual;\n    } else {\n      throw new Error(\"Chess Piece is not on Board.\");\n    }\n  }\n  /**\n   * This event is triggered, when any tile is clicked. Based on its state,\n   * the Board decides which action to take.\n   */\n  public onClick(p: Position) {\n    if (this.selection == null) {\n      this.onBeginSelection(p);\n    } else {\n      this.onCommandMove(this.selection, p);\n      if (this.pacoBoard.chainingPiece != null) {\n        this.selection = this.pacoBoard.chainingPiece.position;\n      } else {\n        this.selection = null;\n      }\n    }\n  }\n  private onCommandMove(start: Position, target: Position) {\n    try {\n      this.pacoBoard.move(start, target);\n    } catch (error) {\n      simpleLog(\"Error while moving: \" + error);\n    }\n  }\n  private onBeginSelection(p: Position) {\n    let legalMoves = this.pacoBoard.select(p);\n    if (legalMoves != null && legalMoves.length > 0) {\n      this.selection = p;\n    }\n  }\n  get selection(): Position | null {\n    return this._selection;\n  }\n  set selection(newSelection: Position | null) {\n    // Clear old highlight, if there was one.\n    if (this._selection != null) {\n      this.tiles.get(this._selection).clearHighlight();\n    }\n    this._selection = newSelection;\n    // Add new highlight, if there is one.\n    if (newSelection != null) {\n      this.tiles.get(newSelection).setHighlight();\n    }\n  }\n}\n\nfunction loadPieceSprite(chessPiece: ChessPiece): PIXI.Sprite {\n  if (chessPiece.color == PlayerColor.white) {\n    switch (chessPiece.type) {\n      case PieceType.pawn:\n        return PIXI.Sprite.fromImage(whitePawnFile, undefined, 1);\n      case PieceType.rock:\n        return PIXI.Sprite.fromImage(whiteRockFile, undefined, 1);\n      case PieceType.knight:\n        return PIXI.Sprite.fromImage(whiteKnightFile, undefined, 1);\n      case PieceType.bishop:\n        return PIXI.Sprite.fromImage(whiteBishopFile, undefined, 1);\n      case PieceType.queen:\n        return PIXI.Sprite.fromImage(whiteQueenFile, undefined, 1);\n      case PieceType.king:\n        return PIXI.Sprite.fromImage(whiteKingFile, undefined, 1);\n      default:\n        return chessPiece.type; // Here piece is of type never, so we may return it as a Pixi.Sprite\n    }\n  } else {\n    switch (chessPiece.type) {\n      case PieceType.pawn:\n        return PIXI.Sprite.fromImage(blackPawnFile, undefined, 1);\n      case PieceType.rock:\n        return PIXI.Sprite.fromImage(blackRockFile, undefined, 1);\n      case PieceType.knight:\n        return PIXI.Sprite.fromImage(blackKnightFile, undefined, 1);\n      case PieceType.bishop:\n        return PIXI.Sprite.fromImage(blackBishopFile, undefined, 1);\n      case PieceType.queen:\n        return PIXI.Sprite.fromImage(blackQueenFile, undefined, 1);\n      case PieceType.king:\n        return PIXI.Sprite.fromImage(blackKingFile, undefined, 1);\n      default:\n        return chessPiece.type; // Here piece is of type never, so we may return it as a Pixi.Sprite\n    }\n  }\n}\n\n/**\n * Here Piece can't extend PIXI.Sprite, as we initialize the sprite via a\n * static function, not a constructor.\n */\nclass VisualPiece {\n  public sprite: PIXI.Sprite;\n  constructor(readonly data: ChessPiece) {\n    this.sprite = loadPieceSprite(data);\n    data.positionObs.subscribe(_ => this.recalculatePosition());\n    data.stateObs.subscribe(_ => this.recalculatePosition());\n    this.recalculatePosition();\n  }\n  get color(): PlayerColor {\n    return this.data.color;\n  }\n  get offset(): Vector {\n    if (this.data.state == PieceState.alone) {\n      return Vector.zero;\n    }\n    if (this.data.state == PieceState.dancing) {\n      if (this.color == PlayerColor.white) {\n        return Vector.x(20);\n      } else {\n        return Vector.x(-20);\n      }\n    }\n    if (this.data.state == PieceState.takingOver) {\n      if (this.color == PlayerColor.white) {\n        return new Vector(10, 10);\n      } else {\n        return new Vector(-10, 10);\n      }\n    }\n    if (this.data.state == PieceState.leavingUnion) {\n      if (this.color == PlayerColor.white) {\n        return new Vector(30, -10);\n      } else {\n        return new Vector(-30, -10);\n      }\n    }\n    return Vector.zero;\n  }\n  recalculatePosition() {\n    const pos = pixelPosition(this.data.position).add(this.offset);\n    this.sprite.x = pos.x;\n    this.sprite.y = pos.y;\n  }\n  isAt(p: Position): any {\n    return this.data.position.x == p.x && this.data.position.y == p.y;\n  }\n}\n\n/**\n * Calculates the screen position of a tile position relative to the board.\n */\nfunction pixelPosition(p: Position): Vector {\n  return new Vector(100 * p.x, 700 - 100 * p.y);\n}\n\napp.stage.addChild(boardBackground());\nlet board = new Board();\nboard.x = 50;\nboard.y = 50;\napp.stage.addChild(board);\n"]}